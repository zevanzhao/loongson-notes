# 前言

在学习龙架构汇编语言时，我参考的是这本书：《汇编语言编程基础： 基于Loongarch》, 孙国云、敖琪、王锐著，北京：人民邮电出版社，2023.1（2023.11重印）。书中有多处错误，但目前在网上找不到官方的勘误。在这里，我把我自己找到的错误列出来，希望对其他读者有所帮助。

##  第3页
图1-2 中，介绍 `ADDI.D rd, rj, si12` 指令时，右侧的操作数错写为`si12 ri rd`, 应为`si12, rj, rd`。

## 第17页
书中，对汇编指令“addi.d $r3, $r3, -16(0xff0)”进行机器编码的二进制结果为
`0b0000001011 000000010000 00011 00011`, 对应的十六进制为`0x02c04063`

但是，`-16`是一个负数，原码表示为`0000 0001 0000`, 其二进制补码表示为`1111 1111 0000`。所以，最终的这条指令的二进制结果应该为
`0b0000001011 111111110000 00011 00011 `
对应的十六进制为 `0x02ffc063`。

## 第40页
32位整型数据的尾端转换，使用C语言实现为
```C
int reverse_dst = (src<<24) | ((src &0xff00) <<8) | ((src >>>8)& 0xff00) | (src >>>24);
```
首先，不存在`>>>`这种用法。其次，当src为负数时，算术右移会在自动在前面补上1,以保持负数，此时结果就是错的。正确的做法是右移之前用掩码去掉将最左侧的位置为0。正确的语句为
```C
int reverse_dst = ((src & 0xFF000000) >> 24) |
                  ((src & 0x00FF0000) >> 8)   |
                  ((src & 0x0000FF00) << 8)   |
                 ((src & 0x000000FF) << 24);
```

# 第69页
例 4.5 编写`float fv = (a<b)?a:b;`的汇编语句。书中给出的汇编语句为
```asm
fcmp.slt.s fcc0, f0. f1
bceqz fcc0, 0x4
fmov.s f2, f0
fmov.s f2, f1
```
事实上，这段语句中`fmov.s f2, f1`一定会执行，因此给出的答案一定是错的。正确的汇编语句应该是
```asm
fcmp.slt.s fcc0, f0. f1
bceqz fcc0, 0x8
fmov.s f2, f0
b 4
fmov.s f2, f1
```
可以参考第52页例3.25的汇编代码。

## 第77页
书中提到“x86采用的是大尾端字节序列存储”，实际上x86也采用小尾端。

Motorola 6800、Motorola 68000、PowerPC 970、System/370、SPARC（除V9外）等处理器为大端序。

参考: [字节序](https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F)。

书中还提到，`可以先写入一个short或者int类型数据到一个内存地址，然后再从此内存地址读出一字节数据，如果此数值为写入数据的低8位，则为大尾端，否则为小尾端`。事实上，**如果数值为写入数据的低8位，为小尾端，否则为大尾端**。

## 第163页
10.3 指令融合和地址对齐中，
指令`shl r3, 3`不是一个真实存在的指令。
指令`alsl_d r2, r3, r2, 2`，应该为`alsl.d r2, r3, r2, 2`。

## 第166~168页
以166页为例，如下有一段汇编代码：
```asm
i1 Loop: fld.f fa0, 0(r1)
                | 1
i2       fadd.f fa2, fa0, fa1
                | 2
i3       fsd.f  fa2, 0(r1)
i4       addi.w r1, r1, -4
i5       bnez  r1, Loop
```
实际上 `fld.f`, `fadd.f`, `fsd.f`指令都不存在，应该是`fld.s`, `fadd.s`, `fst.s`指令。
